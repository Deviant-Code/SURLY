import java.util.List;
import java.util.LinkedList;
import java.util.Queue;
import java.util.NoSuchElementException;

// Class for parsing a surly file
//
// Implemented as an (almost) LL(1) Parser
//
// Every method includes a rough BNF description of the parse, though
// sometimes the parse is slightly different.
// Note for the BNF:
//   * : Zero or more
//   + : One or more
//   Parens can be contextually interpreted as literal or part of the BNF
public class Parser {
    private Peekable<Token> input;
    private List<ParseException> errors;

    public Parser(Peekable<Token> input) {
        this.input = input;
        errors = new LinkedList<ParseException>();
    }

    // Gets the errors generated by a parse;
    public List<ParseException> getErrors() {
        return errors;
    }

    //Main parse method
    //Handles syntax and formatting errors with ParseExceptions
    public Queue<Command> parse() {
        // SURLY ::= <Command>*
        Queue<Command> commands = new LinkedList<Command>();

        // Loop through all tokens
        while(input.hasNext()) {
            try {
                try {
                    // Parse the command
                    commands.add(parseCommand());
                } catch (ParseException e) {
                    errors.add(e);

                    // Move token to the next semicolon to recover from error
                    if (e.lastToken() != Token.TokenType.SEMICOLON) {
                        for (Token token = input.next();
                             !token.is(Token.TokenType.SEMICOLON);
                             token = input.next())
                            ;
                    }
                }
            } catch (NoSuchElementException e) {
                // -1, -1 is ugly, but parse exceptions require line and column
                // information, which this error by definition lacks. The
                // erroneous line and column are evident in the error, anyways.
                errors.add(new ParseException("Got EOF before statement ended",
                        Token.TokenType.SEMICOLON, -1, -1));
            }
        }

        return commands;
    }

    //Handles identifier commands and calls respective method
    //Throws exception if identifier is unkown
    // 
    // Command ::= <CommandRelation> ;
    //           | <CommandInsert> ;
    //           | <CommandPrint> ;
    //           | <CommandDestroy> ;
    //           | <CommandDelete> ;
    //           | <CommandAssignment> ;
    private Command parseCommand() throws ParseException {
        //Pull in next command
        Token token = input.peek();
        String value = token.expect(Token.TokenType.IDENT);

        Command command;

        if (value.equalsIgnoreCase("RELATION")) {
            command = parseRelation();
        } else if (value.equalsIgnoreCase("INSERT")) {
            command = parseInsert();
        } else if (value.equalsIgnoreCase("PRINT")) {
            command = parsePrint();
        } else if (value.equalsIgnoreCase("DESTROY")) {
            command = parseDestroy();
        } else if (value.equalsIgnoreCase("DELETE")) {
            command = parseDelete();
        } else {
            command = parseAssign();
        }

        input.next().expect(Token.TokenType.SEMICOLON);
        return command;
    }

    //Handles delete command to remove tuples from relations in db
    // 
    // CommandDelete ::= DELETE <ident> WHERE <Condition>
    private CommandDelete parseDelete() throws ParseException {
        String name = input.next().expect(Token.TokenType.IDENT);

        Token token = input.next();
        String relationName = token.expect(Token.TokenType.IDENT);

        token = input.peek();

        Condition conditions = new ConditionEmpty();
        if(token.is("WHERE")){
            input.next();
            conditions = parseCondition();
        }

        return new CommandDelete(relationName, conditions);
    }

    // Handles variable assignment commands
    //
    // CommandAssignment ::= <ident> = <Query>
    private CommandAssignment parseAssign() throws ParseException {
        String name = input.next().expect(Token.TokenType.IDENT);

        Token token = input.next();
        String val = token.expect(Token.TokenType.SYMBOL);

        //Check for equality syntax
        if(!val.equals("=")){
            throw token.panic("Equality symbol not found");
        }

        return new CommandAssignment(name, parseQuery());
    }

    //Parses queries involving temp relations for SELECT, PROJECT and JOIN operations
    //
    // Query ::= <QuerySelect> | <QueryJoin> | <QueryIdent>
    private Query parseQuery() throws ParseException {

        Token token = input.next();
        if(token.is(Token.TokenType.LPARENS)){
            Query q = parseQuery();
            input.next().expect(Token.TokenType.RPARENS);
            return q;
        } else {

            String queryCommand = token.expect(Token.TokenType.IDENT);

            if(queryCommand.equalsIgnoreCase("SELECT")){
                return parseQuerySelect();
            } else if(queryCommand.equalsIgnoreCase("PROJECT")){
                return parseQueryProject();
            } else if(queryCommand.equalsIgnoreCase("JOIN")){
                return parseQueryJoin();
            } else {
                throw token.panic("Query type '" + queryCommand
                        + "' not recognized");
            }

        }
    }

    //Return a Query for the Select Command
    //
    // QuerySelect ::= SELECT <Query> WHERE <Condition>
    private QuerySelect parseQuerySelect() throws ParseException {
        Token token = input.next();
        Query q;
        if (token.is(Token.TokenType.LPARENS)) {
            q = parseQuery();
            input.next().expect(Token.TokenType.RPARENS);
        } else {
            String relation = token.expect(Token.TokenType.IDENT);
            q = new QueryIdent(relation);
        }

        token = input.peek();

        Condition conditions = new ConditionEmpty();
        if(token.is("WHERE")){
            input.next();
            conditions = parseCondition();
        }

        return new QuerySelect(q, conditions);
    }

    // Parses an attribute expression
    //
    // AttrExpr ::= <ident>             // Non aggregate
    //            | <ident> ( <ident> ) // Aggrevate
    private AttrExpr parseAttrExpr() throws ParseException {
        String name = input.next().expect(Token.TokenType.IDENT);

        if (input.peek().is(Token.TokenType.LPARENS)) {
            input.next();
            String fnName = name;
            name = input.next().expect(Token.TokenType.IDENT);
            input.next().expect(Token.TokenType.RPARENS);

            return new AttrExprAggr(name, fnName);
        }
        else {
            return new AttrExpr(name);
        }
    }

    //Return a Query for the Project Command
    //
    // QueryProject ::= PROJECT <AttrExpr>* FROM <Query>
    private QueryProject parseQueryProject() throws ParseException {
        List<AttrExpr> attrs = new LinkedList<AttrExpr>();

        //Add attributes to list until reaching FROM.
        while (!input.peek().is("FROM")){
            attrs.add(parseAttrExpr());
        }

        input.next();

        Query q;
        Token token = input.next();
        if (token.is(Token.TokenType.LPARENS)) {
            q = parseQuery();
            input.next().expect(Token.TokenType.RPARENS);
        } else {
            String relation = token.expect(Token.TokenType.IDENT);
            q = new QueryIdent(relation);
        }

        return new QueryProject(q, attrs);
    }

    //Ex. J = JOIN COURSE, PREREQ ON CNUM = PNUM
    //Joins two relations based on specified join condition
    //
    // QueryJoin ::= JOIN <Query> <Query> ON <Condition>
    private QueryJoin parseQueryJoin() throws ParseException {

        //Handles left query
        Token token = input.next();
        Query leftQ, rightQ;
        if (token.is(Token.TokenType.LPARENS)) {
            leftQ = parseQuery();
            input.next().expect(Token.TokenType.RPARENS);
        } else {
            String relation = token.expect(Token.TokenType.IDENT);
            leftQ = new QueryIdent(relation);
        }

        //Handles right query
        token = input.next();
        if (token.is(Token.TokenType.LPARENS)) {
            rightQ = parseQuery();
            input.next().expect(Token.TokenType.RPARENS);
        } else {
            String relation = token.expect(Token.TokenType.IDENT);
            rightQ = new QueryIdent(relation);
        }

        input.next().expect("ON");

        return new QueryJoin(leftQ, rightQ, parseCondition());
    }

    // Condition ::= <ConditionOr>
    private Condition parseCondition() throws ParseException {
        return parseConditionOr();
    }

    // The parsing of ConditionBool is broken into two separate methods to
    // support operator precedence of AND
    //
    // ConditionOr ::= <ConditionAnd>
    //               | <ConditionAnd> OR <ConditionOr>
    private Condition parseConditionOr() throws ParseException {
        Condition left = parseConditionAnd();

        if (input.peek().is(ConditionBool.OR)) {
            String op = input.next().expect(Token.TokenType.IDENT);
            return new ConditionBool(left, parseConditionOr(), op);
        }
        else {
            return left;
        }
    }

    // ConditionAnd ::= <ConditionCompare>
    //                | <ConditionCompare> AND <ConditionAnd>
    private Condition parseConditionAnd() throws ParseException {
        Condition left = parseConditionCompare();

        if (input.peek().is(ConditionBool.AND)) {
            String op = input.next().expect(Token.TokenType.IDENT);
            return new ConditionBool(left, parseConditionAnd(), op);
        }
        else {
            return left;
        }
    }

    // ConditionCompare ::= ( <Condition> )
    //                    | <value> <symbol> <value>
    private Condition parseConditionCompare() throws ParseException {
        Token token = input.next();

        if (token.is(Token.TokenType.LPARENS)) {
            Condition cond = parseCondition();
            input.next().expect(Token.TokenType.RPARENS);
            return cond;
        }
        else {
            String left = token.expectValue();
            String op = input.next().expect(Token.TokenType.SYMBOL);
            String right = input.next().expectValue();
            return new ConditionCompare(left, right, op);
        }
    }

    //Handles 'Relation' command
    //
    // CommandRelation ::= RELATION <ident> ( (<ident> <ident> <number>)+ )
    private CommandRelation parseRelation() throws ParseException {
        input.next().expect("RELATION");

        // Attributes in relational schema
        List<CommandRelation.AttrInfo> attrs =
            new LinkedList<CommandRelation.AttrInfo>();

        // Relation Name
        String name = input.next().expect(Token.TokenType.IDENT);

        input.next().expect(Token.TokenType.LPARENS);

        //Continue to check schema format and add to relation until RPARENS
        for (Token token = input.next();
             !token.is(Token.TokenType.RPARENS);
             token = input.next()) {
            
            String attrName = token.expect(Token.TokenType.IDENT);

            String attrType = input.next().expect(Token.TokenType.IDENT);

            int attrSize = Integer.parseInt(input.next()
                    .expect(Token.TokenType.NUMBER));
            attrs.add(new CommandRelation.AttrInfo(attrName,
                                                   attrType,
                                                   attrSize));
        }

        return new CommandRelation(name, attrs);
    }

    //Handles 'Insert' command
    //
    // CommandInsert := INSERT <ident> <value>+
    private CommandInsert parseInsert() throws ParseException {
        input.next().expect("INSERT");
        // Relation name
        String name = input.next().expect(Token.TokenType.IDENT);

        List<String> values = new LinkedList<String>();

        for (Token token = input.peek();
             !token.is(Token.TokenType.SEMICOLON);
             token = input.peek()) {

            String value = token.expectValue();

            values.add(value);

            input.next();
        }

        return new CommandInsert(name, values);
    }

    //Handles 'Print' command for printing relations
    //
    // CommandPrint ::= PRINT <ident>+
    public CommandPrint parsePrint() throws ParseException {
        input.next().expect("PRINT");

        Queue<String> toPrint = new LinkedList<String>();

        //Add toPrint to list until reaching break char ";"
        for (Token token = input.peek();
                !token.is(Token.TokenType.SEMICOLON);
                token = input.peek()) {
            toPrint.add(token.expect(Token.TokenType.IDENT));

            input.next();
        }

        return new CommandPrint(toPrint);
    }

    // Handles 'Destroy' command
    //
    // CommandDestroy ::= DESTROY <ident>
    public CommandDestroy parseDestroy() throws ParseException {
        input.next().expect("DESTROY");
        String name = input.next().expect(Token.TokenType.IDENT);

        return new CommandDestroy(name);
    }
}
